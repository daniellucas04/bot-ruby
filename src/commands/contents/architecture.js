const { SlashCommandBuilder } = require('@discordjs/builders');
const { MessageEmbed, MessageButton } = require('discord.js');
const paginationEmbed = require('discordjs-button-pagination');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('arquiteturas')
        .setDescription('Vamos conhecer um pouco sobre as arquiteturas mais famosas!'),

    async execute(interaction) {
        const architectureEmbed1 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Arquiteturas')
            .setDescription('Vamos introduzir os princÃ­pios bÃ¡sicos da rede para iniciantes. Rede Ã© um tÃ³pico enorme, entÃ£o isso serÃ¡ apenas uma breve visÃ£o geral.')
            .addFields(
                {
                    name: 'TÃ³picos que vamos abordar',
                    value: '~ Modelo OSI.\n\
                            ~ Modelo TCP/IP.\n\
                            ~ Como esses modelos funcionam na prÃ¡tica.',
                },
            )
            .setTimestamp();

        const architectureEmbed2 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Modelo RM-OSI')
            .setDescription("O modelo OSI (Open Systems Interconnection) Ã© um modelo **padronizado** que usamos para demonstrar a **teoria** por trÃ¡s das redes de computadores.\n\
                             Na prÃ¡tica, Ã© o modelo **TCP/IP** mais compacto no qual a rede do **mundo real se baseia**; no entanto, o modelo OSI, em muitos aspectos, Ã© mais **fÃ¡cil de obter uma compreensÃ£o inicial**.\n\n\
                             **O modelo OSI consiste em sete camadas**")
            .setImage('https://i.imgur.com/5Sd4R7t.png')
            .setTimestamp();

        const architectureEmbed3 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Camadas do Modelo OSI')
            .setDescription('Existem vÃ¡rias formas para ajudÃ¡-lo a memorizar as camadas do modelo OSI - sinta-se a vontade para pesquisar e encontrar uma que goste.')
            .addFields(
                {
                    name: '> AplicaÃ§Ã£o',
                    value: 'A camada de aplicaÃ§Ã£o do modelo OSI essencialmente **fornece opÃ§Ãµes de rede para programas executados em um computador**. Funciona **quase exclusivamente com aplicativos**, fornecendo uma interface para eles usarem para **transmitir dados**. Quando os dados sÃ£o fornecidos Ã  camada de aplicaÃ§Ã£o, eles sÃ£o passados para a camada de **apresentaÃ§Ã£o**.'
                },
                {
                    name: '> ApresentaÃ§Ã£o',
                    value: 'A camada de apresentaÃ§Ã£o recebe dados da camada de **aplicaÃ§Ã£o**. Esses dados tendem a estar em um formato que o **aplicativo entenda**, mas **nÃ£o necessariamente em um formato padronizado** que possa ser entendido pela camada do aplicativo no computador receptor. A camada de apresentaÃ§Ã£o traduz os dados em um **formato padronizado**, alÃ©m de lidar com **qualquer criptografia, compactaÃ§Ã£o ou outras transformaÃ§Ãµes** nos dados. Com isso concluÃ­do, os dados sÃ£o passados para a camada de **sessÃ£o**.'
                },
                {
                    name: '> SessÃ£o',
                    value: 'Quando a camada de sessÃ£o recebe os dados formatados corretamente da camada de apresentaÃ§Ã£o, ela **verifica se pode estabelecer uma conexÃ£o com o outro computador pela rede**. Se nÃ£o puder, ele envia de volta um **erro e o processo nÃ£o avanÃ§a**. Se uma sessÃ£o pode ser estabelecida, Ã© tarefa da camada de sessÃ£o **mantÃª-la**, bem como cooperar com a camada de sessÃ£o do computador remoto para **sincronizar as comunicaÃ§Ãµes**.\n\
                            A camada de sessÃ£o Ã© **particularmente importante**, pois a sessÃ£o que ela cria Ã© exclusiva da comunicaÃ§Ã£o em questÃ£o. Isso Ã© o que permite que vocÃª faÃ§a **vÃ¡rias solicitaÃ§Ãµes para diferentes endpoints simultaneamente sem que todos os dados sejam misturados**.\n\
                            Quando a camada de sessÃ£o estabeleceu com sucesso uma conexÃ£o entre o host e o computador remoto, os dados sÃ£o passados para a camada de **transporte**.'
                }
            )
            .setTimestamp();

        const architectureEmbed4 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Camadas do Modelo OSI - 2')
            .setDescription('> Transporte\nSeu primeiro objetivo Ã© escolher o **protocolo pelo qual os dados serÃ£o transmitidos**. Os dois protocolos mais comuns nesta camada sÃ£o **TCP (Transmission Control Protocol) e UDP (User Datagram Protocol)**')
            .addFields(
                {
                    name: 'TCP',
                    value: 'Em TCP, a transmissÃ£o Ã© **baseada em conexÃ£o**, o que significa que uma conexÃ£o entre os computadores Ã© **estabelecida e mantida durante a solicitaÃ§Ã£o**.\
                            Isso permite uma transmissÃ£o **confiÃ¡vel**, pois a conexÃ£o pode ser usada para garantir que todos os pacotes **cheguem ao lugar certo**.\
                            Uma conexÃ£o TCP permite que os dois computadores **permaneÃ§am em comunicaÃ§Ã£o constante** para garantir que os dados sejam enviados a uma **velocidade aceitÃ¡vel** e que os dados perdidos sejam **reenviados**.'
                },
                {
                    name: 'UDP',
                    value: 'Com UDP, acontece o oposto. Pacotes de dados sÃ£o **essencialmente lanÃ§ados no computador receptor - se ele nÃ£o conseguir acompanhar, o problema Ã© dele**.\
                            EntÃ£o, o TCP geralmente seria escolhido para situaÃ§Ãµes em que a precisÃ£o Ã© favorecida em relaÃ§Ã£o Ã  velocidade, como uma **transferÃªncia de arquivos** por exemplo.\n\
                            E o UDP seria usado em situaÃ§Ãµes em que a **velocidade Ã© mais importante**, por exemplo streaming de vÃ­deo.'
                }
            )

        const architectureEmbed5 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Camadas do Modelo OSI - 3')
            .addFields(
                {
                    name: '> Rede',
                    value: "A camada de rede Ã© responsÃ¡vel por **localizar o destino de sua solicitaÃ§Ã£o**. Por exemplo, a Internet Ã© uma rede enorme; quando vocÃª deseja solicitar informaÃ§Ãµes de uma pÃ¡gina da Web, Ã© a camada de rede que obtÃ©m o endereÃ§o IP da pÃ¡gina e descobre o **melhor caminho a seguir**.\n\
                            Neste estÃ¡gio, estamos trabalhando com o que Ã© chamado de **endereÃ§amento lÃ³gico** (ou seja, endereÃ§os IP) que ainda sÃ£o controlados por software. Os endereÃ§os lÃ³gicos sÃ£o usados para **ordenar as redes**, categorizando-as e permitindo classificÃ¡-las adequadamente.\
                            Atualmente, a forma mais comum de endereÃ§amento lÃ³gico Ã© o formato **IPV4**."
                },
                {
                    name: '> Enlace',
                    value: "A camada de enlace concentra-se no **endereÃ§amento fÃ­sico da transmissÃ£o**.\
                            Ele recebe um pacote da camada de rede (que inclui o IP do computador remoto) e adiciona o **endereÃ§o fÃ­sico (MAC)** do terminal receptor.\n\
                            AlÃ©m disso, tambÃ©m Ã© tarefa da camada de enlace apresentar os dados em um **formato adequado para transmissÃ£o**.\
                            A camada de enlace tambÃ©m cumpre uma funÃ§Ã£o importante quando recebe dados, pois **verifica as informaÃ§Ãµes recebidas** para garantir que nÃ£o foram corrompidas durante a transmissÃ£o, o que pode acontecer quando os dados sÃ£o transmitidos pela camada 1: a camada fÃ­sica."
                },
                {
                    name: '> FÃ­sica',
                    value: 'A camada fÃ­sica estÃ¡ diretamente relacionada ao **hardware do computador**. Ã‰ aqui que os pulsos elÃ©tricos que compÃµem a transferÃªncia de dados em uma rede cabeada sÃ£o **enviados e recebidos**.\
                            Ã‰ o trabalho da camada fÃ­sica **converter os dados binÃ¡rios** da transmissÃ£o em **sinais** e transmiti-los pela rede, alÃ©m de **receber os sinais de entrada e convertÃª-los de volta em dados binÃ¡rios**.'
                }
            )
            .setTimestamp();

        const architectureEmbed6 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Encapsulamento')
            .setDescription('Ã€ medida que os dados sÃ£o passados para cada camada do modelo, mais informaÃ§Ãµes contendo **detalhes especÃ­ficos** da camada em questÃ£o sÃ£o adicionadas ao inÃ­cio da transmissÃ£o.\
                             Por exemplo, o cabeÃ§alho adicionado pela Camada de Rede incluiria coisas como os **IP de origem e destino**, e o cabeÃ§alho adicionado pela Camada de Transporte incluiria (entre outras coisas) **informaÃ§Ãµes especÃ­ficas do protocolo que estÃ¡ sendo usado**.')
            .setTimestamp();

        const architectureEmbed7 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Encapsulamento - 2')
            .setDescription('A camada de enlace tambÃ©m adiciona uma peÃ§a no final da transmissÃ£o, que Ã© usada para **verificar se os dados nÃ£o foram corrompidos na transmissÃ£o**; isso tambÃ©m tem o bÃ´nus adicional de **maior seguranÃ§a**, pois os dados **nÃ£o podem ser interceptados e adulterados**.\n\n\
                             **Todo esse processo Ã© chamado de encapsulamento; o processo pelo qual os dados podem ser enviados de um computador para outro**.')
            .setTimestamp();

        const architectureEmbed8 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Encapsulamento - 3')
            .setDescription('Os dados encapsulados recebem um nome diferente em diferentes **etapas do processo**. Nas camadas 7, 6 e 5, os dados sÃ£o simplesmente referidos como **dados**.\n\n\
                             Na camada de transporte, os **dados encapsulados** sÃ£o chamados de **segmento ou datagrama**.\n\n\
                             Na camada de rede, os dados sÃ£o chamados de **pacotes**. Quando o pacote Ã© passado para a camada de enlace de dados, ele se torna um **quadro** e, no momento em que Ã© transmitido pela rede, **o quadro foi dividido em bits**.')
            .setTimestamp();

        const architectureEmbed9 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Encapsulamento - 4')
            .setDescription('Quando a mensagem Ã© recebida pelo segundo computador, ele inverte o processo â€“ **comeÃ§ando na camada fÃ­sica e trabalhando atÃ© chegar Ã  camada de aplicaÃ§Ã£o**, retirando as informaÃ§Ãµes adicionadas Ã  medida que avanÃ§a.\n\
                             Isto Ã© referido como **desencapsulaÃ§Ã£o**. Como tal, vocÃª pode pensar nas camadas do modelo OSI como **existentes dentro de cada computador com recursos de rede**.\
                             Embora nÃ£o seja tÃ£o claro na **prÃ¡tica**, **todos os computadores seguem o mesmo processo de encapsulamento para enviar dados e desencapsulamento ao recebÃª-los**.')
            .setTimestamp();

        const architectureEmbed10 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Encapsulamento - 5')
            .setDescription('Os processos de encapsulamento e desencapsulamento sÃ£o **muito importantes** - nÃ£o apenas por causa de seu uso prÃ¡tico, mas tambÃ©m porque nos dÃ£o um mÃ©todo **padronizado de envio de dados**.\
                             Isso significa que todas as transmissÃµes seguirÃ£o **consistentemente a mesma metodologia**, permitindo que qualquer dispositivo habilitado para rede envie uma solicitaÃ§Ã£o para qualquer outro dispositivo acessÃ­vel e tenha **certeza de que ela serÃ¡ compreendida**.')
            .setTimestamp();

        const architectureEmbed11 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Modelo TCP/IP')
            .setDescription('O modelo TCP/IP Ã©, em muitos aspectos, muito semelhante ao modelo OSI. Ã‰ alguns anos mais velho e serve como base para a rede do mundo real. O modelo TCP/IP consiste em quatro camadas: **AplicaÃ§Ã£o, Transporte, Internet e Interface de Rede**.\
                             Entre eles, eles cobrem a **mesma gama de funÃ§Ãµes que as sete camadas do Modelo OSI**.')
            .setImage('https://i.imgur.com/Rus8Gv7.png')
            .setTimestamp();

        const architectureEmbed12 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Modelo TCP/IP - 2')
            .setDescription('Veja o modelo OSI, ao lado do modelo TCP/IP')
            .setImage('https://i.imgur.com/29SQKtb.png')
            .setTimestamp();

        const architectureEmbed13 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Modelo TCP/IP - 3')
            .setDescription('O processo de encapsulamento e desencapsulamento do modelo TCP/IP **funciona exatamente da mesma forma do modelo OSI**.\
                             Em cada camada do modelo TCP/IP, um cabeÃ§alho Ã© **adicionado durante o encapsulamento e removido durante o desencapsulamento**.')
            .setImage('https://i.imgur.com/29SQKtb.png')
            .setTimestamp();

        const architectureEmbed14 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Modelo TCP/IP - 4')
            .setDescription('Um modelo em camadas Ã© Ã³timo como auxÃ­lio visual - ele nos mostra o processo geral de como os dados podem ser encapsulados e enviados por uma rede, mas como isso **realmente acontece?**\n\
                             Quando falamos de TCP/IP, Ã© bom pensar em uma tabela com quatro camadas, mas na verdade estamos falando de um **conjunto de protocolos**.\
                             TCP/IP leva o nome dos dois mais importantes deles: o **Transmission Control Protocol** que **controla o fluxo de dados** entre dois terminais, e o Internet Protocol, que controla como os pacotes sÃ£o endereÃ§ados e enviado.')
            .setTimestamp();

        const architectureEmbed15 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Modelo TCP/IP - 5')
            .setDescription('o TCP Ã© um protocolo baseado em conexÃ£o. Em outras palavras, antes de enviar qualquer dado via TCP, vocÃª deve primeiro formar uma **conexÃ£o estÃ¡vel** entre os dois computadores.\
                             O processo de formaÃ§Ã£o dessa conexÃ£o Ã© chamado de **handshake de trÃªs vias**.')
            .setTimestamp();

        const architectureEmbed16 = new MessageEmbed()
            .setColor('NOT_QUITE_BLACK')
            .setTitle('> ðŸ“— Modelo TCP/IP - 6')
            .setDescription('Quando vocÃª tenta fazer uma conexÃ£o, seu computador primeiro envia uma solicitaÃ§Ã£o especial ao servidor remoto indicando que deseja **inicializar uma conexÃ£o**.\
                             Essa solicitaÃ§Ã£o contÃ©m algo chamado bit **SYN (abreviaÃ§Ã£o de sincronizaÃ§Ã£o)**, que essencialmente faz o **primeiro contato** ao iniciar o processo de conexÃ£o. O servidor entÃ£o responderÃ¡ com um pacote contendo o bit SYN, bem como outro bit de **"reconhecimento"**, chamado **ACK**.\n\
                             Finalmente, seu computador enviarÃ¡ um pacote que contÃ©m o bit ACK por si sÃ³, **confirmando que a conexÃ£o foi configurada com sucesso**.\
                             Com o handshake de trÃªs vias concluÃ­do com Ãªxito, os dados podem ser transmitidos de forma confiÃ¡vel entre os dois computadores. Quaisquer dados perdidos ou corrompidos na transmissÃ£o sÃ£o **reenviados**, levando a uma conexÃ£o que parece nÃ£o ter perdas.')
            .setFields(
                {
                    name: 'ReferÃªncias',
                    value: 'TryHackMe. DisponÃ­vel em <https://tryhackme.com/room/introtonetworking> Acesso em 16/06/2022\nTANENBAUM, Andrew S. Redes de Computadores. Rio de Janeiro: Elsevier, 2003.\n'
                }
            )
        
        const button1 = new MessageButton()
            .setCustomId('previousbtn')
            .setLabel('PÃ¡gina Anterior')
            .setStyle('DANGER');

        const button2 = new MessageButton()
            .setCustomId('nextbtn')
            .setLabel('PrÃ³xima pÃ¡gina')
            .setStyle('SUCCESS');

        const pages = [architectureEmbed1, architectureEmbed2, architectureEmbed3, architectureEmbed4, architectureEmbed5, architectureEmbed6, architectureEmbed7, architectureEmbed8, architectureEmbed9, architectureEmbed10, architectureEmbed11, architectureEmbed12, architectureEmbed13, architectureEmbed14, architectureEmbed15, architectureEmbed16 ];
        const buttons = [button1, button2];
        const time = 1000 * 3600;

        paginationEmbed(interaction, pages, buttons, time);
    }
}